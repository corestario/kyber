// Package vss implements the verifiable Secret sharing scheme from
// "Non-Interactive and Information-Theoretic Secure Verifiable Secret Sharing"
// by Torben Pryds Pedersen.
// https://link.springer.com/content/pdf/10.1007/3-540-46766-1_9.pdf
package vss

import (
	"bytes"
	"crypto/cipher"
	"encoding"
	"encoding/binary"
	"encoding/json"
	"errors"
	"fmt"
	"reflect"

	"github.com/corestario/kyber"
	"github.com/corestario/kyber/share"
	"github.com/corestario/kyber/sign/schnorr"
	"go.dedis.ch/protobuf"
)

// Suite defines the capabilities required by the vss package.
type Suite interface {
	encoding.BinaryMarshaler
	encoding.BinaryUnmarshaler
	kyber.HashFactory
	kyber.XOFFactory
	kyber.Random

	// This is kyber.Group, but without the marshalling part.
	String() string
	ScalarLen() int       // Max length of scalars in bytes
	Scalar() kyber.Scalar // Create new scalar
	PointLen() int        // Max length of point in bytes
	Point() kyber.Point   // Create new point
}

// Dealer encapsulates for creating and distributing the shares and for
// replying to any Responses.
type Dealer struct {
	Suite  Suite
	reader cipher.Stream
	// Long is the Longterm key of the Dealer
	Long          kyber.Scalar
	Pub           kyber.Point
	Secret        kyber.Scalar
	SecretCommits []kyber.Point
	SecretPoly    *share.PriPoly
	Verifiers     []kyber.Point
	HkdfContext   []byte
	// threshold of shares that is needed to reconstruct the Secret
	T int
	// SessionIDField is a unique identifier for the whole session of the scheme
	SessionIDField []byte
	// list of Deals this Dealer has generated
	Deals []*Deal
	*Aggregator
}

// Deal encapsulates the verifiable Secret share and is sent by the Dealer to a verifier.
type Deal struct {
	// Unique session identifier for this protocol run
	SessionID []byte
	// Private share generated by the Dealer
	SecShare *share.PriShare
	// Threshold used for this Secret sharing run
	T uint32
	// Commitments are the coefficients used to verify the shares against
	Commitments []kyber.Point
}

// EncryptedDeal contains the AggregatedDeal in a encrypted form only decipherable by the
// correct recipient. The encryption is performed in a similar manner as what is
// done in TLS. The Dealer generates a temporary key pair, signs it with its
// Longterm Secret key.
type EncryptedDeal struct {
	// Ephemeral Diffie Hellman key
	DHKey []byte
	// Signature of the DH key by the Longterm key of the Dealer
	Signature []byte
	// Nonce used for the encryption
	Nonce []byte
	// AEAD encryption of the AggregatedDeal marshalled by protobuf
	Cipher []byte
}

// Response is sent by the verifiers to all participants and holds each
// individual validation or refusal of a Deal.
type Response struct {
	// SessionID related to this run of the protocol
	SessionID []byte
	// Index of the verifier issuing this Response from the new set of nodes
	Index uint32
	// false = NO APPROVAL == Complaint , true = APPROVAL
	Status bool
	// Signature over the whole packet
	Signature []byte
}

const (
	// StatusComplaint is a constant value meaning that a verifier issues
	// a Complaint against its Dealer.
	StatusComplaint bool = false
	// StatusApproval is a constant value meaning that a verifier agrees with
	// the share it received.
	StatusApproval bool = true
)

// Justification is a message that is broadcasted by the Dealer in response to
// a Complaint. It contains the original Complaint as well as the shares
// distributed to the complainer.
type Justification struct {
	// SessionID related to the current run of the protocol
	SessionID []byte
	// Index of the verifier who issued the Complaint,i.e. IndexField of this Deal
	Index uint32
	// Deal in cleartext
	Deal *Deal
	// Signature over the whole packet
	Signature []byte
}

// NewDealer returns a Dealer capable of leading the Secret sharing scheme. It
// does not have to be trusted by other verifiers. The security parameter T is
// the number of shares required to reconstruct the Secret. It is HIGHLY
// RECOMMENDED to use a threshold higher or equal than what the method
// MinimumT() returns, otherwise it breaks the security assumptions of the whole
// scheme. It returns an error if the T is less than or equal to 2.
func NewDealer(suite Suite, longterm, secret kyber.Scalar, verifiers []kyber.Point, t int) (*Dealer, error) {
	d := &Dealer{
		Suite:     suite,
		Long:      longterm,
		Secret:    secret,
		Verifiers: verifiers,
	}
	if !validT(t, verifiers) {
		return nil, fmt.Errorf("Dealer: T %d invalid", t)
	}
	d.T = t

	f := share.NewPriPoly(d.Suite, d.T, d.Secret, suite.RandomStream())
	d.Pub = d.Suite.Point().Mul(d.Long, nil)

	// Compute public polynomial coefficients
	F := f.Commit(d.Suite.Point().Base())
	_, d.SecretCommits = F.Info()

	var err error
	d.SessionIDField, err = sessionID(d.Suite, d.Pub, d.Verifiers, d.SecretCommits, d.T)
	if err != nil {
		return nil, err
	}

	d.Aggregator = NewAggregator(d.Suite, d.Pub, d.Verifiers, d.SecretCommits, d.T, d.SessionIDField)
	// C = F + G
	d.Deals = make([]*Deal, len(d.Verifiers))
	for i := range d.Verifiers {
		fi := f.Eval(i)
		d.Deals[i] = &Deal{
			SessionID:   d.SessionIDField,
			SecShare:    fi,
			Commitments: d.SecretCommits,
			T:           uint32(d.T),
		}
	}
	d.HkdfContext = context(suite, d.Pub, verifiers)
	d.SecretPoly = f
	return d, nil
}

// PlaintextDeal returns the plaintext version of the AggregatedDeal destined for peer i.
// Use this only for testing.
func (d *Dealer) PlaintextDeal(i int) (*Deal, error) {
	if i >= len(d.Deals) {
		return nil, errors.New("Dealer: PlaintextDeal given wrong IndexField")
	}
	return d.Deals[i], nil
}

// EncryptedDeal returns the encryption of the AggregatedDeal that must be given to the
// verifier at IndexField i.
// The Dealer first generates a temporary Diffie Hellman key, signs it using its
// Longterm key, and computes the shared key depending on its Longterm and
// ephemeral key and the verifier's public key.
// This shared key is then fed into a HKDF whose output is the key to a AEAD
// (AES256-GCM) scheme to encrypt the AggregatedDeal.
func (d *Dealer) EncryptedDeal(i int) (*EncryptedDeal, error) {
	vPub, ok := findPub(d.Verifiers, uint32(i))
	if !ok {
		return nil, errors.New("Dealer: wrong IndexField to generate encrypted AggregatedDeal")
	}
	// gen ephemeral key
	dhSecret := d.Suite.Scalar().Pick(d.Suite.RandomStream())
	dhPublic := d.Suite.Point().Mul(dhSecret, nil)
	// signs the public key
	dhPublicBuff, _ := dhPublic.MarshalBinary()
	signature, err := schnorr.Sign(d.Suite, d.Long, dhPublicBuff)
	if err != nil {
		return nil, err
	}
	// AES128-GCM
	pre := dhExchange(d.Suite, dhSecret, vPub)
	gcm, err := newAEAD(d.Suite.Hash, pre, d.HkdfContext)
	if err != nil {
		return nil, err
	}

	nonce := make([]byte, gcm.NonceSize())
	dealBuff, err := protobuf.Encode(d.Deals[i])
	if err != nil {
		return nil, err
	}
	encrypted := gcm.Seal(nil, nonce, dealBuff, d.HkdfContext)
	dhBytes, _ := dhPublic.MarshalBinary()
	return &EncryptedDeal{
		DHKey:     dhBytes,
		Signature: signature,
		Nonce:     nonce,
		Cipher:    encrypted,
	}, nil
}

// EncryptedDeals calls `EncryptedDeal` for each IndexField of the verifier and
// returns the list of encrypted Deals. Each IndexField in the returned slice
// corresponds to the IndexField in the list of verifiers.
func (d *Dealer) EncryptedDeals() ([]*EncryptedDeal, error) {
	deals := make([]*EncryptedDeal, len(d.Verifiers))
	var err error
	for i := range d.Verifiers {
		deals[i], err = d.EncryptedDeal(i)
		if err != nil {
			return nil, err
		}
	}
	return deals, nil
}

// ProcessResponse analyzes the given Response. If it's a valid complaint, then
// it returns a Justification. This Justification must be broadcasted to every
// participants. If it's an invalid complaint, it returns an error about the
// complaint. The verifiers will also ignore an invalid Complaint.
func (d *Dealer) ProcessResponse(r *Response) (*Justification, error) {
	if err := d.verifyResponse(r); err != nil {
		return nil, err
	}
	if r.Status == StatusApproval {
		return nil, nil
	}

	j := &Justification{
		SessionID: d.SessionIDField,
		// IndexField is guaranteed to be good because of d.verifyResponse before
		Index: r.Index,
		Deal:  d.Deals[int(r.Index)],
	}
	sig, err := schnorr.Sign(d.Suite, d.Long, j.Hash(d.Suite))
	if err != nil {
		return nil, err
	}
	j.Signature = sig
	return j, nil
}

// SecretCommit returns the commitment of the Secret being shared by this
// Dealer. This function is only to be called once the AggregatedDeal has enough approvals
// and is verified otherwise it returns nil.
func (d *Dealer) SecretCommit() kyber.Point {
	if !d.DealCertified() {
		return nil
	}
	return d.Suite.Point().Mul(d.Secret, nil)
}

// Commits returns the commitments of the coefficient of the Secret polynomial
// the Dealer is sharing.
func (d *Dealer) Commits() []kyber.Point {
	return d.SecretCommits
}

// Key returns the Longterm key pair used by this Dealer.
func (d *Dealer) Key() (secret kyber.Scalar, public kyber.Point) {
	return d.Long, d.Pub
}

// SessionID returns the current SessionIDField generated by this Dealer for this
// protocol run.
func (d *Dealer) SessionID() []byte {
	return d.SessionIDField
}

// SetTimeout marks the end of a round, invalidating any missing (or future) response
// for this DKG protocol round. The caller is expected to call this after a Long Timeout
// so each DKG node can still compute its share if enough Deals are valid.
func (d *Dealer) SetTimeout() {
	d.Aggregator.Timeout = true
}

// PrivatePoly returns the private polynomial used to generate the AggregatedDeal. This
// private polynomial can be saved and then later on used to generate new
// shares.  This information SHOULD STAY PRIVATE and thus MUST never be given
// to any third party.
func (d *Dealer) PrivatePoly() *share.PriPoly {
	return d.SecretPoly
}

// Verifier receives a Deal from a Dealer, can reply with a Complaint, and can
// collaborate with other verifiers to reconstruct a Secret.
type Verifier struct {
	Suite       Suite
	Longterm    kyber.Scalar
	Pub         kyber.Point
	Dealer      kyber.Point
	IndexField  int
	verifiers   []kyber.Point
	HkdfContext []byte
	*Aggregator
}

type Verifiers []kyber.Point

func (v Verifiers) MarshalBinary() ([]byte, error) {
	var temp [][]byte
	for _, p := range v {
		bz, err := p.MarshalBinary()
		if err != nil {
			panic(err)
		}
		temp = append(temp, bz)
	}

	return json.Marshal(temp)
}

func (v *Verifiers) UnmarshalBinary(data []byte) error {
	var temp [][]byte
	if err := json.Unmarshal(data, &temp); err != nil {
		panic(err)
	}

	for _, _ = range temp {

	}

	return nil
}

// NewVerifier returns a Verifier out of:
//   - its Longterm Secret key
//   - the Longterm Dealer public key
//   - the list of public key of verifiers. The list MUST include the public key of this Verifier also.
// The security parameter T of the Secret sharing scheme is automatically set to
// a default safe value. If a different T value is required, it is possible to set
// it with `verifier.SetT()`.
func NewVerifier(suite Suite, longterm kyber.Scalar, dealerKey kyber.Point,
	verifiers []kyber.Point) (*Verifier, error) {

	pub := suite.Point().Mul(longterm, nil)
	var ok bool
	var index int
	for i, v := range verifiers {
		if v.Equal(pub) {
			ok = true
			index = i
			break
		}
	}
	if !ok {
		return nil, errors.New("vss: public key not found in the list of verifiers")
	}
	v := &Verifier{
		Suite:       suite,
		Longterm:    longterm,
		Dealer:      dealerKey,
		verifiers:   verifiers,
		Pub:         pub,
		IndexField:  index,
		HkdfContext: context(suite, dealerKey, verifiers),
		Aggregator:  NewEmptyAggregator(suite, verifiers),
	}
	return v, nil
}

// ProcessEncryptedDeal decrypt the AggregatedDeal received from the Dealer.
// If the AggregatedDeal is valid, i.e. the verifier can verify its shares
// against the public coefficients and the signature is valid, an approval
// response is returned and must be broadcasted to every participants
// including the Dealer.
// If the AggregatedDeal itself is invalid, it returns a complaint response that must be
// broadcasted to every other participants including the Dealer.
// If the AggregatedDeal has already been received, or the signature generation of the
// response failed, it returns an error without any ResponsesMap.
func (v *Verifier) ProcessEncryptedDeal(e *EncryptedDeal) (*Response, error) {
	d, err := v.DecryptDeal(e)
	if err != nil {
		return nil, err
	}
	if d.SecShare.I != v.IndexField {
		return nil, errors.New("vss: verifier got wrong IndexField from AggregatedDeal")
	}

	t := int(d.T)

	sid, err := sessionID(v.Suite, v.Dealer, v.verifiers, d.Commitments, t)
	if err != nil {
		return nil, err
	}

	r := &Response{
		SessionID: sid,
		Index:     uint32(v.IndexField),
		Status:    StatusApproval,
	}
	if err = v.VerifyDeal(d, true); err != nil {
		r.Status = StatusComplaint
	}

	if err == errDealAlreadyProcessed {
		return nil, err
	}

	if r.Signature, err = schnorr.Sign(v.Suite, v.Longterm, r.Hash(v.Suite)); err != nil {
		return nil, err
	}

	if err = v.Aggregator.addResponse(r); err != nil {
		return nil, err
	}
	return r, nil
}

func (v *Verifier) DecryptDeal(e *EncryptedDeal) (*Deal, error) {
	// verify signature
	if err := schnorr.Verify(v.Suite, v.Dealer, e.DHKey, e.Signature); err != nil {
		return nil, err
	}

	// compute shared key and AES526-GCM cipher
	dhKey := v.Suite.Point()
	if err := dhKey.UnmarshalBinary(e.DHKey); err != nil {
		return nil, err
	}
	pre := dhExchange(v.Suite, v.Longterm, dhKey)
	gcm, err := newAEAD(v.Suite.Hash, pre, v.HkdfContext)
	if err != nil {
		return nil, err
	}
	decrypted, err := gcm.Open(nil, e.Nonce, e.Cipher, v.HkdfContext)
	if err != nil {
		return nil, err
	}
	deal := &Deal{}
	err = deal.decode(v.Suite, decrypted)
	return deal, err
}

// ErrNoDealBeforeResponse is an error returned if a verifier receives a
// AggregatedDeal before having received any ResponsesMap. For the moment, the caller must
// be sure to have dispatched a AggregatedDeal before.
var ErrNoDealBeforeResponse = errors.New("verifier: need to receive AggregatedDeal before response")

// ProcessResponse analyzes the given response. If it's a valid complaint, the
// verifier should expect to see a Justification from the Dealer. It returns an
// error if it's not a valid response.
// Call `v.DealCertified()` to check if the whole protocol is finished.
func (v *Verifier) ProcessResponse(resp *Response) error {
	if v.Aggregator.AggregatedDeal == nil {
		return ErrNoDealBeforeResponse
	}
	return v.Aggregator.verifyResponse(resp)
}

// Commits returns the commitments of the coefficients of the polynomial
// contained in the Deal received. It is public information. The private
// information in the AggregatedDeal must be retrieved through Deal().
func (v *Verifier) Commits() []kyber.Point {
	return v.AggregatedDeal.Commitments
}

// Deal returns the Deal that this verifier has received. It returns
// nil if the AggregatedDeal is not certified or there is not enough approvals.
func (v *Verifier) Deal() *Deal {
	if !v.DealCertified() {
		return nil
	}
	return v.AggregatedDeal
}

// ProcessJustification takes a DealerResponse and returns an error if
// something went wrong during the verification. If it is the case, that
// probably means the Dealer is acting maliciously. In order to be sure, call
// `v.DealCertified()`.
func (v *Verifier) ProcessJustification(dr *Justification) error {
	return v.Aggregator.verifyJustification(dr)
}

// Key returns the Longterm key pair this verifier is using during this protocol
// run.
func (v *Verifier) Key() (kyber.Scalar, kyber.Point) {
	return v.Longterm, v.Pub
}

// Index returns the IndexField of the verifier in the list of participants used
// during this run of the protocol.
func (v *Verifier) Index() int {
	return v.IndexField
}

// SessionID returns the session id generated by the Dealer. It returns
// an nil slice if the verifier has not received the Deal yet.
func (v *Verifier) SessionID() []byte {
	return v.Sid
}

// RecoverSecret recovers the Secret shared by a Dealer by gathering at least T
// Deals from the verifiers. It returns an error if there is not enough Deals or
// if all Deals don'T have the same SessionID.
func RecoverSecret(suite Suite, deals []*Deal, n, t int) (kyber.Scalar, error) {
	shares := make([]*share.PriShare, len(deals))
	for i, deal := range deals {
		// all sids the same
		if bytes.Equal(deal.SessionID, deals[0].SessionID) {
			shares[i] = deal.SecShare
		} else {
			return nil, errors.New("vss: all Deals need to have same session id")
		}
	}
	return share.RecoverSecret(suite, shares, t, n)
}

// SetTimeout marks the end of the protocol. The caller is expected to call this
// after a Long Timeout so each verifier can still deem its share valid if
// enough Deals were approved. One should call `DealCertified()` after this
// method in order to know if the AggregatedDeal is valid or the protocol should abort.
func (v *Verifier) SetTimeout() {
	v.Aggregator.Timeout = true
}

// UnsafeSetResponseDKG is an UNSAFE bypass method to allow DKG to use VSS
// that works on basis of approval only.
func (v *Verifier) UnsafeSetResponseDKG(idx uint32, approval bool) {
	r := &Response{
		SessionID: v.Aggregator.Sid,
		Index:     uint32(idx),
		Status:    approval,
	}

	v.Aggregator.addResponse(r)
}

// Aggregator is used to collect all Deals, and ResponsesMap for one protocol run.
// It brings common functionalities for both Dealer and Verifier structs.
type Aggregator struct {
	Suite     Suite
	Dealer    kyber.Point
	Verifiers []kyber.Point
	Commits   []kyber.Point

	ResponsesMap   map[uint32]*Response
	Sid            []byte
	AggregatedDeal *Deal
	T              int
	BadDealer      bool
	Timeout        bool
}

func NewAggregator(suite Suite, dealer kyber.Point, verifiers, commitments []kyber.Point, t int, sid []byte) *Aggregator {
	agg := &Aggregator{
		Suite:        suite,
		Dealer:       dealer,
		Verifiers:    verifiers,
		Commits:      commitments,
		T:            t,
		Sid:          sid,
		ResponsesMap: make(map[uint32]*Response),
	}
	return agg
}

// NewEmptyAggregator returns a structure capable of storing Responses about a
// AggregatedDeal and check if the AggregatedDeal is certified or not.
func NewEmptyAggregator(suite Suite, verifiers []kyber.Point) *Aggregator {
	return &Aggregator{
		Suite:        suite,
		Verifiers:    verifiers,
		ResponsesMap: make(map[uint32]*Response),
	}
}

var errDealAlreadyProcessed = errors.New("vss: verifier already received a AggregatedDeal")

// VerifyDeal analyzes the AggregatedDeal and returns an error if it's incorrect. If
// inclusion is true, it also returns an error if it is the second time this struct
// analyzes a Deal.
func (a *Aggregator) VerifyDeal(d *Deal, inclusion bool) error {
	if a.AggregatedDeal != nil && inclusion {
		return errDealAlreadyProcessed

	}
	if a.AggregatedDeal == nil {
		a.Commits = d.Commitments
		a.Sid = d.SessionID
		a.AggregatedDeal = d
		a.T = int(d.T)
	}

	if !validT(int(d.T), a.Verifiers) {
		return errors.New("vss: invalid T received in Deal")
	}

	if int(d.T) != a.T {
		return errors.New("vss: incompatible threshold - potential attack")
	}

	if !bytes.Equal(a.Sid, d.SessionID) {
		return errors.New("vss: find different sessionIDs from Deal")
	}

	fi := d.SecShare
	if fi.I < 0 || fi.I >= len(a.Verifiers) {
		return errors.New("vss: IndexField out of bounds in Deal")
	}
	// compute fi * G
	fig := a.Suite.Point().Base().Mul(fi.V, nil)

	commitPoly := share.NewPubPoly(a.Suite, nil, d.Commitments)

	pubShare := commitPoly.Eval(fi.I)
	if !fig.Equal(pubShare.V) {
		return errors.New("vss: share does not verify against commitments in Deal")
	}
	return nil
}

// SetThreshold is used to specify the expected threshold *before* the verifier
// receives anything. Sometimes, a verifier knows the treshold in advance and
// should make sure the one it receives from the Dealer is consistent. If this
// method is not called, the first threshold received is considered as the
// "truth".
func (a *Aggregator) SetThreshold(t int) {
	a.T = t
}

// ProcessResponse verifies the validity of the given response and stores it
// internall. It is  the public version of verifyResponse created this way to
// allow higher-level package to use these functionalities.
func (a *Aggregator) ProcessResponse(r *Response) error {
	return a.verifyResponse(r)
}

func (a *Aggregator) verifyResponse(r *Response) error {
	if a.Sid != nil && !bytes.Equal(r.SessionID, a.Sid) {
		return errors.New("vss: receiving inconsistent SessionIDField in response")
	}

	pub, ok := findPub(a.Verifiers, r.Index)
	if !ok {
		return errors.New("vss: IndexField out of bounds in response")
	}

	if err := schnorr.Verify(a.Suite, pub, r.Hash(a.Suite), r.Signature); err != nil {
		return err
	}

	return a.addResponse(r)
}

func (a *Aggregator) verifyJustification(j *Justification) error {
	if _, ok := findPub(a.Verifiers, j.Index); !ok {
		return errors.New("vss: IndexField out of bounds in justification")
	}
	r, ok := a.ResponsesMap[j.Index]
	if !ok {
		return errors.New("vss: no complaints received for this justification")
	}
	if r.Status != StatusComplaint {
		return errors.New("vss: justification received for an approval")
	}

	if err := a.VerifyDeal(j.Deal, false); err != nil {
		// if one justification is bad, then flag the Dealer as malicious
		a.BadDealer = true
		return err
	}
	r.Status = StatusApproval
	return nil
}

func (a *Aggregator) addResponse(r *Response) error {
	if _, ok := findPub(a.Verifiers, r.Index); !ok {
		return errors.New("vss: IndexField out of bounds in Complaint")
	}
	if _, ok := a.ResponsesMap[r.Index]; ok {
		return errors.New("vss: already existing response from same origin")
	}
	a.ResponsesMap[r.Index] = r
	return nil
}

// Responses returns the list of ResponsesMap received and processed by this
// aggregator
func (a *Aggregator) Responses() map[uint32]*Response {
	return a.ResponsesMap
}

// DealCertified returns true if the AggregatedDeal is certified.
// For a AggregatedDeal to be certified, it needs to comply to the following
// conditions in two different cases, since we are not working with the
// synchrony assumptions from Feldman's VSS:
// Before the Timeout (i.e. before the "period" ends):
// 1. there is at least T approvals
// 2. all complaints must be justified (a complaint becomes an approval when
// justified) -> no complaints
// 3. there must not be absent ResponsesMap
// After the Timeout, when the "period" ended, we replace the third condition:
// 3. there must not be more than n-T missing ResponsesMap (otherwise it is not
// possible to retrieve the Secret).
// If the caller previously called `SetTimeout` and `DealCertified()` returns
// false, the protocol MUST abort as the AggregatedDeal is not and never will be validated.
func (a *Aggregator) DealCertified() bool {
	var absentVerifiers int
	var approvals int
	var isComplaint bool

	for i := range a.Verifiers {
		if r, ok := a.ResponsesMap[uint32(i)]; !ok {
			absentVerifiers++
		} else if r.Status == StatusComplaint {
			isComplaint = true
		} else if r.Status == StatusApproval {
			approvals++
		}
	}
	enoughApprovals := approvals >= a.T
	tooMuchAbsents := absentVerifiers > len(a.Verifiers)-a.T
	baseCondition := !a.BadDealer && enoughApprovals && !isComplaint
	if a.Timeout {
		return baseCondition && !tooMuchAbsents
	}
	return baseCondition && !(absentVerifiers > 0)
}

// MissingResponses returns the indexes of the expected but missing ResponsesMap.
func (a *Aggregator) MissingResponses() []int {
	var absents []int
	for i := range a.Verifiers {
		if _, ok := a.ResponsesMap[uint32(i)]; !ok {
			absents = append(absents, i)
		}
	}
	return absents
}

// MinimumT returns the minimum safe T that is proven to be secure with this
// protocol. It expects n, the total number of participants.
// WARNING: Setting a lower T could make
// the whole protocol insecure. Setting a higher T only makes it harder to
// reconstruct the Secret.
func MinimumT(n int) int {
	return (n + 1) / 2
}

func validT(t int, verifiers []kyber.Point) bool {
	return t >= 2 && t <= len(verifiers) && int(uint32(t)) == t
}

func deriveH(suite Suite, verifiers []kyber.Point) kyber.Point {
	var b bytes.Buffer
	for _, v := range verifiers {
		_, _ = v.MarshalTo(&b)
	}
	base := suite.Point().Pick(suite.XOF(b.Bytes()))
	return base
}

func findPub(verifiers []kyber.Point, idx uint32) (kyber.Point, bool) {
	iidx := int(idx)
	if iidx >= len(verifiers) {
		return nil, false
	}
	return verifiers[iidx], true
}

func sessionID(suite Suite, dealer kyber.Point, verifiers, commitments []kyber.Point, t int) ([]byte, error) {
	h := suite.Hash()
	_, _ = dealer.MarshalTo(h)

	for _, v := range verifiers {
		_, _ = v.MarshalTo(h)
	}

	for _, c := range commitments {
		_, _ = c.MarshalTo(h)
	}
	_ = binary.Write(h, binary.LittleEndian, uint32(t))

	return h.Sum(nil), nil
}

// Hash returns the Hash representation of the Response
func (r *Response) Hash(s Suite) []byte {
	h := s.Hash()
	_, _ = h.Write([]byte("response"))
	_, _ = h.Write(r.SessionID)
	_ = binary.Write(h, binary.LittleEndian, r.Index)
	_ = binary.Write(h, binary.LittleEndian, r.Status)
	return h.Sum(nil)
}

func (d *Deal) decode(s Suite, buff []byte) error {
	constructors := make(protobuf.Constructors)
	var point kyber.Point
	var secret kyber.Scalar
	constructors[reflect.TypeOf(&point).Elem()] = func() interface{} { return s.Point() }
	constructors[reflect.TypeOf(&secret).Elem()] = func() interface{} { return s.Scalar() }
	return protobuf.DecodeWithConstructors(buff, d, constructors)
}

// Hash returns the hash of a Justification.
func (j *Justification) Hash(s Suite) []byte {
	h := s.Hash()
	_, _ = h.Write([]byte("justification"))
	_, _ = h.Write(j.SessionID)
	_ = binary.Write(h, binary.LittleEndian, j.Index)
	buff, _ := protobuf.Encode(j.Deal)
	_, _ = h.Write(buff)
	return h.Sum(nil)
}
